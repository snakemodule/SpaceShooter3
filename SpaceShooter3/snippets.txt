
	struct element {
		unsigned next;
		Entity entity;
	};

	struct hole {
		unsigned next;
	};

	union index_entry {
		element element = { 0, nil_entity() };
		hole hole;
	};
	
	extern std::vector<index_entry> enemy_bullet_index;
	extern std::vector<index_entry> enemy_index;
	extern std::vector<index_entry> player_bullet_index;

void init_index(std::vector<index_entry>& index) {
		//0 is a hole list, following 80 entries are the buckets subdividing the playfield.
		index.resize(81);
		index[0].hole.next = 0;
}

void update_index(std::vector<index_entry>& index, Position current_pos, Entity e, Position new_pos)
{
		unsigned current_bucket = find_bucket_one_dimension(current_pos.x, current_pos.y);
		unsigned new_bucket = find_bucket_one_dimension(new_pos.x, new_pos.y);

		assert(index[new_bucket].element.entity == nil_entity());

		if (current_bucket == new_bucket)
			return;

		unsigned prev = current_bucket;
		unsigned i = index[current_bucket].element.next;
		while (index[i].element.entity.id != e.id)
		{
			prev = i;
			i = index[i].element.next;
			assert(i != 0); //the value was not in the index as expected.
		}

		//remove from list
		index[prev].element.next = index[i].element.next;
		//add to head of other bucket list
		unsigned tail = index[new_bucket].element.next;
		index[new_bucket].element.next = i;
		index[i].element.next = tail;

		//std::cout << "updated\n";
		//print_bucket(index, current_bucket);
		//print_bucket(index, new_bucket);
}

void add_to_index(std::vector<index_entry>& index, Position pos, Entity e)
	{
		unsigned bucket = find_bucket_one_dimension(pos.x, pos.y);

		assert(index[bucket].element.entity == nil_entity());
		//unsigned prev = bucket;
		//unsigned i = index[bucket].element.next;
		//while (index[i].element.component_array_index != value)
		//{
		//	prev = i;
		//	i = index[i].element.next;
		//	assert(i != 0); //the value was not in the index as expected.
		//}


		unsigned placement;
		if (index[0].hole.next > 0)
		{
			placement = index[0].hole.next;
			index[0].hole.next = index[placement].hole.next;
			index[placement] = { 0, e };
		}
		else {
			index.push_back({ 0, e });
			placement = index.size() - 1;
		}
		

		unsigned tail = index[bucket].element.next;
		index[bucket].element.next = placement;
		index[placement].element.next = tail;

		//index[bucket].element.component_array_index = 1337;
	}

void remove_from_index(std::vector<index_entry>& index, Position pos, Entity e) {
		unsigned bucket = find_bucket_one_dimension(pos.x, pos.y);

		unsigned prev = bucket;
		unsigned i = index[bucket].element.next;
		while (index[i].element.entity.id != e.id)
		{
			prev = i;
			i = index[i].element.next;
			assert(i != 0); //the value was not in the index as expected.
		}

		index[prev].element.next = index[i].element.next;
		index[i] = index_entry{};

		unsigned hole_tail = index[0].hole.next;
		index[0].hole.next = i;
		index[i].hole.next = hole_tail;
	}

void xyfrombucket(size_t bucket, int& x, int& y)
	{
		const unsigned width_count = (640 + 80 + 80) / 80; //todo get from window

		bucket -= 1;

		x = bucket % width_count;

		bucket -= x;

		y = bucket / width_count;

		y *= 80;
		x *= 80;

		x -= 80;
		y -= 80;
	}

void draw_buckets() {
		const unsigned width_count = (640 + 80 + 80) / 80;

		for (size_t i = 1; i < 81; i++)
		{
			if (enemy_bullet_index[i].element.next != 0)
			{
				int x, y;
				xyfrombucket(i, x, y);
				SDL_Rect rect = { x,y, 80,80 };
				SDL_RenderDrawRect(window_renderer, &rect);
			}
		}
	}

	void print_bucket(std::vector<index_entry> index, unsigned bucket) {
		//printf("bucket: %\n", );
		std::cout << "bucket: " << bucket << ": ";
		unsigned i = bucket;
		while (index[i].element.next != 0)
		{
			std::cout << index[i].element.next << " ";
		}
		std::cout << "\n";
	}


	//---------------------------------------

	#pragma once
#include <vector>

template<typename T, int elements_per_chunk = 16>
class swiss_array
{
	struct hole	{
		unsigned int next_hole = 0;
	};

	struct item_t {
		unsigned int generation = 0;
		union {
			T element;
			hole hole;
		};

		item_t() {};
	};

	struct chunk
	{
		item_t items[elements_per_chunk];		
	};

	std::vector<chunk*> chunks = { new chunk };
	unsigned int last_chunk_item_count = 1;
		
	item_t& access_item(unsigned int i)
	{
		return chunks[i / elements_per_chunk]->items[i % elements_per_chunk];
	}

	T& access_element(unsigned int i) 
	{
		return access_item(i).element;
	}

	hole& access_hole(unsigned int i) 
	{
		return access_item(i).hole;
	}

	hole& get_hole_header() 
	{
		return chunks[0]->items[0].hole;
	}

	//bulk_data_t* bd,
	void delete_item(unsigned int i) {
		// Add to the freelist, which is stored in slot 0.
		access_hole(i).next_hole = get_hole_header().next_hole;
		get_hole_header().next_hole = i;

		++access_item(i).generation;
	}

	unsigned int allocate_slot() {
		const unsigned int slot = get_hole_header().next_hole;
		get_hole_header().next_hole = access_hole(slot).next_hole;
		// If the freelist is empty, slot will be 0, because the header
		// item will point to itself.
		if (slot) return slot;

		if (last_chunk_item_count < elements_per_chunk)	{
			++last_chunk_item_count;
		}
		else {
			chunks.push_back(new chunk);
			last_chunk_item_count = 1;
		}
		return ((chunks.size() - 1) * (elements_per_chunk)) + (last_chunk_item_count - 1);

		//bd->items.resize(bd->items.size() + 1);
		//return bd->items.size() - 1;
	}
};


//Loads individual image as texture
SDL_Texture* loadTexture(std::string path) 
{
    //The final texture
    SDL_Texture* newTexture = nullptr;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load(path.c_str());
    if (loadedSurface == nullptr)
    {
        printf("Unable to load image %s! SDL_image Error: %s\n", path.c_str(), IMG_GetError());
    }
    else
    {
        //Create texture from surface pixels
        newTexture = SDL_CreateTextureFromSurface(window_renderer, loadedSurface);
        if (newTexture == nullptr)
        {
            printf("Unable to create texture from %s! SDL Error: %s\n", path.c_str(), SDL_GetError());
        }

        //Get rid of old loaded surface
        SDL_FreeSurface(loadedSurface);
    }

    return newTexture;
}

bool load_media() {
    //Loading success flag
    bool success = true;

    //Load PNG texture
    texture = loadTexture("images\\hello_world.png");
    if (texture == nullptr)
    {
        printf("Failed to load texture image!\n");
        success = false;
    }

    return success;
}

//struct fuzzy_hasher
	//{
	//	static inline uint64_t mix(uint64_t a, uint64_t b)
	//	{
	//		a *= 0xc6a4a7935bd1e995ULL;
	//		a ^= a >> 47ULL;
	//		a *= 0xc6a4a7935bd1e995ULL;
	//		return a ^ b;
	//	}
	//
	//	size_t operator()(const Position& p) const 
	//	{
	//		const uint64_t ix = (uint64_t)(p.x / 10.0f + (float)INT64_MAX);
	//		const uint64_t iy = (uint64_t)(p.y / 10.0f + (float)INT64_MAX);
	//		const uint64_t key = mix(ix, iy);
	//		return key;
	//	};
	//};

	
	//struct space_bucketing {
	//	size_t operator()(const Position& p) const
	//	{
	//		int32_t x;
	//		int32_t y;
	//		x = p.x / 80; //truncating
	//		y = p.y / 80;
	//
	//		x = (p.x < 0) ? x - 1 : x;
	//		y = (p.y < 0) ? y - 1 : y;
	//					
	//		size_t result = static_cast<size_t>(x) << 32;
	//		result |= y;
	//
	//		return result;
	//	};
	//};